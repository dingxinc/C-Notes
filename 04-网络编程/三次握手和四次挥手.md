

TCP 协议是一个安全的、面向连接的、流式传输协议，所谓的面向连接就是三次握手，对于程序猿来说只需要在客户端调用 `connect()` 函数，三次握手就自动进行了。先通过下图看一下 TCP 协议的格式，然后再介绍三次握手的具体流程。



# 1. TCP 协议介绍



![image-20230914164617750](https://mater-1312713760.cos.ap-guangzhou.myqcloud.com/img/202309141646798.png)

![image-20230914164737273](https://mater-1312713760.cos.ap-guangzhou.myqcloud.com/img/202309141647350.png)

* 窗口大小：该字段长 16 位，表示从确认序号所指位置开始能够接收的数据大小，TCP 不允许发送超过该窗口大小的数据。



# 2. 三次握手

Tcp 连接是双向连接，客户端和服务器需要分别向对方发送连接请求，并且建立连接，三次握手成功之后，二者之间的双向连接也就成功建立了。如果要保证三次握手顺利完成，必须要满足以下条件：

* 服务器端：已经启动，并且启动了监听（被动接受连接的一端）
* 客户端：基于服务器端监听的 IP 和端口，向服务器端发起连接请求（主动发起连接的一端）



![image-20230914165254193](https://mater-1312713760.cos.ap-guangzhou.myqcloud.com/img/202309141652295.png)

三次握手具体过程如下：

第一次握手：

* 客户端：客户端向服务器端发起连接请求将报文中的 SYN 字段置为 1，生成随机序号 x，seq=x
* 服务器端：接收客户端发送的请求数据，解析 tcp 协议，校验 SYN 标志位是否为 1，并得到序号  x

第二次握手：

* 服务器端：给客户端回复数据

  1. 回复 ACK, 将 tcp 协议 ACK 对应的标志位设置为 1，表示同意了客户端建立连接的请求
  2. 回复了 ack=x+1, 这是确认序号
     * x: 客户端生成的随机序号
     * 1: 客户端给服务器发送的数据的量,  SYN 标志位存储到某一个字节中, 因此按照一个字节计算，表示客户端给服务器发送的1个字节服务器收到了。
  3. 将 tcp 协议中的 SYN 对应的标志位设置为 1, 服务器向客户端发起了连接请求
  4. 服务器端生成了一个随机序号 y, 发送给了客户端

* 客户端：接收回复的数据，并解析 tcp 协议

  1. 校验 ACK 标志位，为 1 表示服务器接收了客户端的连接请求

  2. 数据校验，确认发送给服务器的数据服务器收到了没有，计算公式如下：

     发送的数据的量 = 使用服务器回复的确认序号 - 客户端生成的随机序号 ===> 1=x+1-x

  3. 校验 SYN 标志位，为 1 表示服务器请求和客户端建立连接

  4. 得到服务器生成的随机序号: y



第三次握手：

* 客户端：发送数据给服务器

  1. 将 tcp 协议中 ACK 标志位设置为 1，表示同意了服务器的连接请求
  2. 给服务器回复了一个确认序号 ack = y+1
     * y：服务器端生成的随机序号
     * 1：服务器给客户端发送的数据量，服务器给客户端发送了 ACK 和 SYN,  都存储在这一个字节中
  3. 发送给服务器的序号就是上一次从服务器端收的确认序号因此 seq = x+1

* 服务器端：接收数据,  并解析 tcp 协议

  1. 查看 ACK 对应的标志位是否为 1, 如果是 1 代表,  客户端同意了服务器的连接请求

  2. 数据校验，确认发送给客户端的数据客户端收到了没有，计算公式如下：

     给客户端发送的数据量 = 确认序号 - 服务器生成的随机序号 ===> 1=y+1-y

  3. 得到客户端发送的序号：x+1



![image-20230914172019836](https://mater-1312713760.cos.ap-guangzhou.myqcloud.com/img/202309141720869.png)



# 3. TCP  四次挥手

四次挥手是断开连接的过程，需要双向断开，关于由哪一端先断开连接是没有要求的。通信的两端如果想要断开连接就需要调用 `close()` 函数，当两端都调用了该函数，四次挥手也就完成了。

* 客户端和服务器断开连接 -> 单向断开
* 服务器和客户端断开连接 -> 单向断开

进行了两次单向断开，双向断开就完成了，每进行一次单向断开，就会完成两次挥手的动作。



![image-20230914172150216](https://mater-1312713760.cos.ap-guangzhou.myqcloud.com/img/202309141721327.png)





# 4. 流量控制

流量控制可以让发送端根据接收端的实际接受能力控制发送的数据量。它的具体操作是，`接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不会超过该大小的数据，该限制大小即为窗口大小，即窗口大小由接收端主机决定。`

TCP 首部中，专门有一个字段来通知窗口大小，接收主机将自己可以接收的缓冲区大小放在该字段中通知发送端。`当接收端的缓冲区面临数据溢出时，窗口大小的值也是随之改变，设置为一个更小的值通知发送端，从而控制数据的发送量，这样达到流量的控制。`这个控制流程的窗口也可以称作滑动窗口。

![image-20230914172303278](https://mater-1312713760.cos.ap-guangzhou.myqcloud.com/img/202309141723321.png)

左侧是数据发送端：对应的是发送端的写缓冲区(内存)，通过一个环形队列进行数据管理

* 白色格子: 空闲的内存, 可以写数据
* 粉色的格子: 被写入到内存, 但是还没有被发送出去的数据
* 灰色的格子: 代表已经被发送出去的数据



右侧是数据接收端：对应的是接收端的读缓冲区，存储发送端发送过来的数据

* 白色格子：空闲的内存, 可以继续接收数据, 滑动窗口的值记录的就是白色的格子的大小
  * 随着接收的数据越来越多, 白色格子越来越少, 滑动窗口的值越来越小
  * 如果白色格子没有了, 滑动窗口变为0, 这时候, 发送端就被阻塞了
* 粉色格子：接收的数据，但是这个数据还没有从内核中读走，使用 read() / recv()
  * 粉色格子变少了, 可用空间就变多了, 滑动窗口的值就变大了
  * 如果滑动窗口的值从 0 变为大于 0, 接收端又重新有容量接收数据了,  发送端的阻塞自动解除，继续发送数据



基于TCP通信的流程图，记录了从三次握手 -> 数据通信 -> 四次挥手是全过程：

![image-20230914172452624](https://mater-1312713760.cos.ap-guangzhou.myqcloud.com/img/202309141724711.png)



```shell
# fast sender: 客户端
# slow recerver: 服务器
# win: 滑动窗口大小
# mss: maximum segment size, 单条数据的最大长度
```

